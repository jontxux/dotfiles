# Ajustes Generales
set preview true
set icons
set hidden
set ignorecase true
set drawbox true
set sixel true
set previewer '~/dotfiles/lf/preview'

# Comandos Personalizados

# Búsqueda con FZF
cmd fzf_search ${{
    RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
    res="$(
        FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
            fzf --bind "change:reload:$RG_PREFIX {q} || true" \
            --ansi --layout=reverse --header 'Search in files' \
            | cut -d':' -f1 | sed 's/\\/\\\\/g;s/"/\\"/g'
    )"
    [ -n "$res" ] && lf -remote "send $id select \"$res\""
}}

# Salto con FZF
cmd fzf_jump ${{
    res="$(fd . | fzf --reverse --header='Jump to location')"
    if [ -n "$res" ]; then
        if [ -d "$res" ]; then
            cmd="cd"
        else
            cmd="select"
        fi
        res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
        lf -remote "send $id $cmd \"$res\""
    fi
}}

# Integración con zoxide
cmd z %{{
	result="$(zoxide query --exclude $PWD $@ | sed 's/\\/\\\\/g;s/"/\\"/g')"
	lf -remote "send $id cd \"$result\""
}}
cmd zi ${{
	result="$(zoxide query -i | sed 's/\\/\\\\/g;s/"/\\"/g')"
	lf -remote "send $id cd \"$result\""
}}
cmd on-cd &{{
        zoxide add "$PWD"
}}

# Apertura de archivos basada en MIME
cmd open ${{
    case $(file --mime-type -b "$f") in
        text/*|application/json) $EDITOR "$f" ;;
        application/pdf) setsid -f zathura "$f" >/dev/null 2>&1 & ;;
        audio/*|video/*) setsid -f mpv -- "$f" >/dev/null 2>&1 & ;;
        image/*) setsid -f imv "$f" >/dev/null 2>&1 & ;;
        *) setsid -f xdg-open "$f" >/dev/null 2>&1 & ;;
    esac
}}

# Creación de directorios
cmd mkdir $mkdir -p "$@"

# Extracción de archivos
cmd extract ${{
    # Configuración de estilos
    BOLD=$(tput bold)
    BLUE=$(tput setaf 4)
    MAGENTA=$(tput setaf 5)
    CYAN=$(tput setaf 6)
    GREEN=$(tput setaf 2)
    RED=$(tput setaf 1)
    RESET=$(tput sgr0)
    CHECK=$'\u2713'  # ✓
    CROSS=$'\u2717'  # ✗

    clear
    set -f
    
    # Encabezado
    printf "%b%s%b\n" "${BOLD}${BLUE}╭── EXTRAER ARCHIVO ───${RESET}"
    printf "%bArchivo seleccionado:%b\n" "${BOLD}" "${RESET}"
    echo "  ${fx}"
    printf "%b%s%b\n" "${BOLD}${BLUE}╰──────────────────────${RESET}"
    
    # Confirmación
    read -p "${BOLD}${MAGENTA}¿Extraer archivo? [y/N]: ${RESET}" ans
    
    if [ "$ans" = "y" ]; then
        # Directorio destino
        read -p "${BOLD}${MAGENTA}Ruta destino (dejar vacío para actual): ${RESET}" directorio_destino
        
        # Validación y formato del directorio
        directorio_destino="${directorio_destino:-./}"
        [[ "$directorio_destino" != */ ]] && directorio_destino+="/"
        
        # Crear directorio si no existe
        if [ ! -d "$directorio_destino" ]; then
            printf "%bCreando directorio: %s%b\n" "${CYAN}" "$directorio_destino" "${RESET}"
            mkdir -p "$directorio_destino" || {
                printf "%b%s %b%s%b\n" "${RED}${BOLD}" "${CROSS}" "${RESET}" "Error creando directorio"
                sleep 1.5
                return 1
            }
        fi

        # Proceso de extracción
        printf "\n%b%s%b\n" "${CYAN}⌛ Extrayendo archivos...${RESET}"
        
        case "$fx" in
            *.tar.bz2|*.tbz2)  cmd="tar xjvf '${fx}' -C '${directorio_destino}'" ;;
            *.tar.gz|*.tgz)     cmd="tar xzvf '${fx}' -C '${directorio_destino}'" ;;
            *.bz2)             cmd="bunzip2 -kc '${fx}' > '${directorio_destino}${fx##*/}'" ;;
            *.rar)              cmd="unrar x '${fx}' '${directorio_destino}'" ;;
            *.gz)              cmd="gunzip -c '${fx}' > '${directorio_destino}${fx##*/}'" ;;
            *.tar)              cmd="tar xvf '${fx}' -C '${directorio_destino}'" ;;
            *.zip)              cmd="unzip -q '${fx}' -d '${directorio_destino}'" ;;
            *.Z)                cmd="uncompress -c '${fx}' > '${directorio_destino}${fx##*/}'" ;;
            *.7z)               cmd="7z x -y '${fx}' -o'${directorio_destino}'" ;;
            *.tar.xz)           cmd="tar xvf '${fx}' -C '${directorio_destino}'" ;;
            *)                  cmd="echo 'Formato no soportado'" ;;
        esac

        # Ejecutar y mostrar resultado
        if eval "$cmd"; then
            printf "\r%b%-50s %b%s%b\n" "${GREEN}" "${CHECK} Éxito: " "${RESET}" "Extracción completada"
            sleep 1
            lf -remote "send load"
        else
            printf "\r%b%-50s %b%s%b\n" "${RED}" "${CROSS} Error: " "${RESET}" "Fallo en la extracción"
            sleep 1.5
        fi
    else
        printf "%b%s%b\n" "${MAGENTA}" "${CROSS} Operación cancelada" "${RESET}"
        sleep 1
    fi
}}

# Compresión de archivos
cmd comprimir ${{
    # Configuración de estilos
    BOLD=$(tput bold)
    BLUE=$(tput setaf 4)
    MAGENTA=$(tput setaf 5)
    CYAN=$(tput setaf 6)
    GREEN=$(tput setaf 2)
    RESET=$(tput sgr0)
    CHECK=$'\u2713'  # ✓
    CROSS=$'\u2717'  # ✗

    clear
    set -f  # Desactivar expansión de globbing
    
    # Encabezado
    printf "%b%s%b\n" "${BOLD}${BLUE}╭── COMPRIMIR ARCHIVOS ──${RESET}"
    printf "%bArchivos seleccionados:%b\n" "${BOLD}" "${RESET}"
    echo "$fx" | nl -s ") " -w 2 | sed "s/^/  /"
    printf "%b%s%b\n" "${BOLD}${BLUE}╰──────────────────────────${RESET}"
    
    # Input con estilo
    read -p "${BOLD}${MAGENTA}Nombre del archivo comprimido: ${RESET}" nombre_comprimido
    
    if [ -z "$nombre_comprimido" ]; then
        printf "\n%b%-50s %b%s%b\n" "${CYAN}" "${CROSS} Error: " "${RESET}" "Nombre no proporcionado"
        sleep 1
        return
    fi

    # Convertir a rutas relativas
    current_dir=$(pwd)
    relative_files=$(echo "$fx" | while IFS= read -r file; do
        realpath --relative-to="$current_dir" "$file"
    done)

    # Proceso de compresión con manejo de espacios
    safe_files=$(echo "$relative_files" | xargs -d '\n' printf "%q " 2>/dev/null)
    
    case "$nombre_comprimido" in
        *.zip)
            command="zip -jr \"$nombre_comprimido\" $safe_files" ;;
        *.tar.gz|*.tgz)
            command="tar -czvf \"$nombre_comprimido\" $safe_files" ;;
        *.tar.xz)
            command="tar -cJvf \"$nombre_comprimido\" $safe_files" ;;
        *.tar.bz2|*.tbz2)
            command="tar -cjvf \"$nombre_comprimido\" $safe_files" ;;
        *.7z)
            command="7z a \"$nombre_comprimido\" $safe_files" ;;
        *.rar)
            command="rar a \"$nombre_comprimido\" $safe_files" ;;
        *)
            printf "\n%b%-50s %b%s%b\n" "${CYAN}" "${CROSS} Error: " "${RESET}" "Extensión no soportada"
            sleep 1.5
            return
            ;;
    esac

    # Ejecución con feedback visual
    printf "\n%b%s%b\n" "${CYAN}⌛ Comprimiendo archivos...${RESET}"
    if eval "$command"; then
        printf "\r%b%-50s %b%s%b\n" "${GREEN}" "${CHECK} Éxito: " "${RESET}" "Archivo creado: $nombre_comprimido"
    else
        printf "\r%b%-50s %b%s%b\n" "${CYAN}" "${CROSS} Error: " "${RESET}" "Fallo en la compresión"
    fi
    
    sleep 1.5
    lf -remote "send load"
}}

# Creación de nuevos archivos
cmd nuevo ${{
    # Generar códigos ANSI en cada ejecución
    BOLD=$(tput bold)
    BLUE=$(tput setaf 4)
    MAGENTA=$(tput setaf 5)
    CYAN=$(tput setaf 6)
    GREEN=$(tput setaf 2)
    RESET=$(tput sgr0)
    CHECK=$'\u2713'  # ✓
    CROSS=$'\u2717'  # ✗

    clear
    # Encabezado estilo delete
    printf "%b%s%b\n" "${BOLD}${BLUE}╭── NUEVO ARCHIVO ────${RESET}"
    
    # Input con estilo consistente
    read -p "${BOLD}${MAGENTA}Nombre del archivo: ${RESET}" nombre_archivo
    
    # Pie de sección
    printf "%b%s%b\n" "${BOLD}${BLUE}╰─────────────────────${RESET}"
    
    if [ -z "$nombre_archivo" ]; then
        printf "\n%b%-50s %b%s%b\n" "${CYAN}" "${CROSS} Error: " "${RESET}" "Nombre no válido"
        sleep 1
        return
    fi
    
    if [ -e "$nombre_archivo" ]; then
        printf "\n%b%-50s %b%s%b\n" "${CYAN}" "${CROSS} Error: " "${RESET}" "El archivo ya existe"
        sleep 1.5
        return
    fi
    
    if touch "$nombre_archivo"; then
        printf "\n%b%-50s %b%s%b\n" "${GREEN}" "${CHECK} Éxito: " "${RESET}" "Archivo creado: $nombre_archivo"
        sleep 1
        lf -remote "send $id select \"$nombre_archivo\""
        lf -remote "send $id reload"
    else
        printf "\n%b%-50s %b%s%b\n" "${CYAN}" "${CROSS} Error: " "${RESET}" "No se pudo crear el archivo"
        sleep 1.5
    fi
}}

# Eliminación de archivos
cmd delete ${{
    # Generar códigos ANSI en cada ejecución
    BOLD=$(tput bold)
    BLUE=$(tput setaf 4)      # Reemplaza rojo
    MAGENTA=$(tput setaf 5)   # Reemplaza amarillo
    CYAN=$(tput setaf 6)      # Nuevo color
    GREEN=$(tput setaf 2)
    RESET=$(tput sgr0)
    CHECK=$'\u2713'  # ✓
    CROSS=$'\u2717'  # ✗

    clear
    files_count=$(echo "$fx" | grep -c '^')
    
    # Calcular tamaño total
    total_size=$(echo "$fx" | xargs -d '\n' du -sch 2>/dev/null | grep total | cut -f1)
    [ -z "$total_size" ] && total_size="0"
    
    printf "%b%s%b\n" "${BOLD}${BLUE}╭── ELIMINACIÓN DE ARCHIVOS ──${RESET}"
    printf "%bArchivos seleccionados:%b\n" "${BOLD}" "${RESET}"
    echo "$fx" | nl -s ") " -w 2 | sed "s/^/  /"
    printf "\n%bTamaño total: %s%b\n" "${BOLD}${CYAN}" "${total_size}" "${RESET}"
    printf "%b%s%b\n" "${BOLD}${BLUE}╰─────────────────────────────${RESET}"
    
    read -p "${BOLD}${MAGENTA}¿Eliminar permanentemente? [y/N]:${RESET} " ans
    
    if [ "$ans" = "y" ]; then
        errors=0
        while IFS= read -r -d $'\n' file; do
            [ -z "$file" ] && continue
            printf "%bEliminando %s...%b" "${MAGENTA}" "$file" "${RESET}"
            if rm -rf "$file"; then
                printf "\r%b%-50s %b%s%b\n" "${GREEN}" "${CHECK} $file" "${RESET}" "OK"
            else
                printf "\r%b%-50s %b%s%b\n" "${CYAN}" "${CROSS} $file" "${RESET}" "ERROR"
                ((errors++))
            fi
        done <<< "$fx"
        
        [ $errors -eq 0 ] && status="${GREEN}Completado sin errores${RESET}" || status="${CYAN}Completado con $errors error(es)${RESET}"
        printf "%b%s%b\n" "${BOLD}" "Resultado: $status" "${RESET}"
        sleep 2
        lf -remote "send load"
    else
        printf "%b%s%b\n" "${BOLD}${MAGENTA}" "${CROSS} Operación cancelada" "${RESET}"
        sleep 1
    fi
}}

# Mapeo de Teclas
map <enter> open
map D delete
map E extract
map Z comprimir
map T nuevo

# Mapeos de teclas para operaciones comunes
map <f-7> push :mkdir<space>""<left>
map <c-r> reload
map <c-s> set hidden!
map x $$f
map X !$f

# Mapeos de teclas para renombrar
map A :rename; cmd-end
map C push A<c-u>
map I :rename; cmd-home
map i :rename
map a :rename; cmd-right

# Navegación y operaciones misceláneas
map <c-n> down
map <c-p> up
map V push :!vim<space>
map Y $printf "%s" "$fx" | wl-copy
map gs :fzf_search
map gf :fzf_jump


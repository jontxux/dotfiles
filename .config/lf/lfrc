# Ajustes Generales
set preview true
set icons
set hidden
set ignorecase true
set drawbox true
set sixel true
set previewer '~/dotfiles/.config/lf/preview'

# Comandos Personalizados

# Búsqueda con FZF
cmd fzf_search ${{
    RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
    res="$(
        FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
            fzf --bind "change:reload:$RG_PREFIX {q} || true" \
            --ansi --layout=reverse --header 'Search in files' \
            | cut -d':' -f1 | sed 's/\\/\\\\/g;s/"/\\"/g'
    )"
    [ -n "$res" ] && lf -remote "send $id select \"$res\""
}}

# Salto con FZF
cmd fzf_jump ${{
    res="$(fd . | fzf --reverse --header='Jump to location')"
    if [ -n "$res" ]; then
        if [ -d "$res" ]; then
            cmd="cd"
        else
            cmd="select"
        fi
        res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
        lf -remote "send $id $cmd \"$res\""
    fi
}}

# Integración con zoxide
cmd z %{{
    result="$(zoxide query --exclude $PWD $@ | sed 's/\\/\\\\/g;s/"/\\"/g')"
    lf -remote "send $id cd \"$result\""
}}
cmd zi ${{
    result="$(zoxide query -i | sed 's/\\/\\\\/g;s/"/\\"/g')"
    lf -remote "send $id cd \"$result\""
}}
cmd on-cd &{{
        zoxide add "$PWD"
}}

# Apertura de archivos basada en MIME
cmd open ${{
    case $(file --mime-type -b "$f") in
        text/*|application/json|application/pgp-*) $EDITOR "$f" ;;
        application/pdf) setsid -f zathura "$f" >/dev/null 2>&1 & ;;
        audio/*|video/*) setsid -f mpv -- "$f" >/dev/null 2>&1 & ;;
        image/*) setsid -f imv "$f" >/dev/null 2>&1 & ;;
        *) setsid -f xdg-open "$f" >/dev/null 2>&1 & ;;
    esac
}}

# Creación de directorios
cmd mkdir $mkdir -p "$@"

# Extracción de archivos
cmd extract ${{
    bash ~/.config/lf/scripts/extract.sh "$fx"
}}

# Compresión de archivos
cmd comprimir ${{
    bash ~/.config/lf/scripts/compress.sh "$fx"
}}

# Creación de nuevos archivos
cmd nuevo ${{
    # Generar códigos ANSI en cada ejecución
    BOLD=$(tput bold)
    BLUE=$(tput setaf 4)
    MAGENTA=$(tput setaf 5)
    CYAN=$(tput setaf 6)
    GREEN=$(tput setaf 2)
    RESET=$(tput sgr0)
    CHECK=$'\u2713'  # ✓
    CROSS=$'\u2717'  # ✗

    clear
    # Encabezado estilo delete
    printf "%b%s%b\n" "${BOLD}${BLUE}╭── NUEVO ARCHIVO ────${RESET}"

    # Input con estilo consistente
    read -p "${BOLD}${MAGENTA}Nombre del archivo: ${RESET}" nombre_archivo

    # Pie de sección
    printf "%b%s%b\n" "${BOLD}${BLUE}╰─────────────────────${RESET}"

    if [ -z "$nombre_archivo" ]; then
        printf "\n%b%-50s %b%s%b\n" "${CYAN}" "${CROSS} Error: " "${RESET}" "Nombre no válido"
        read -p "${BOLD}${MAGENTA}Presione Enter para continuar...${RESET}"
        return
    fi

    if [ -e "$nombre_archivo" ]; then
        printf "\n%b%-50s %b%s%b\n" "${CYAN}" "${CROSS} Error: " "${RESET}" "El archivo ya existe"
        read -p "${BOLD}${MAGENTA}Presione Enter para continuar...${RESET}"
        return
    fi

    if touch "$nombre_archivo"; then
        printf "\n%b%-50s %b%s%b\n" "${GREEN}" "${CHECK} Éxito: " "${RESET}" "Archivo creado: $nombre_archivo"
        read -p "${BOLD}${MAGENTA}Presione Enter para continuar...${RESET}"
        lf -remote "send $id select \"$nombre_archivo\""
        lf -remote "send load"
    else
        printf "\n%b%-50s %b%s%b\n" "${CYAN}" "${CROSS} Error: " "${RESET}" "No se pudo crear el archivo"
        read -p "${BOLD}${MAGENTA}Presione Enter para continuar...${RESET}"
    fi
}}

# Eliminación de archivos
cmd delete ${{
    # Generar códigos ANSI en cada ejecución
    BOLD=$(tput bold)
    BLUE=$(tput setaf 4)      # Reemplaza rojo
    MAGENTA=$(tput setaf 5)   # Reemplaza amarillo
    CYAN=$(tput setaf 6)      # Nuevo color
    GREEN=$(tput setaf 2)
    RESET=$(tput sgr0)
    CHECK=$'\u2713'  # ✓
    CROSS=$'\u2717'  # ✗

    clear
    files_count=$(echo "$fx" | grep -c '^')

    # Calcular tamaño total
    total_size=$(echo "$fx" | xargs -d '\n' du -sch 2>/dev/null | grep total | cut -f1)
    [ -z "$total_size" ] && total_size="0"

    printf "%b%s%b\n" "${BOLD}${BLUE}╭── ELIMINACIÓN DE ARCHIVOS ──${RESET}"
    printf "%bArchivos seleccionados:%b\n" "${BOLD}" "${RESET}"
    echo "$fx" | nl -s ") " -w 2 | sed "s/^/  /"
    printf "\n%bTamaño total: %s%b\n" "${BOLD}${CYAN}" "${total_size}" "${RESET}"
    printf "%b%s%b\n" "${BOLD}${BLUE}╰─────────────────────────────${RESET}"

    read -p "${BOLD}${MAGENTA}¿Eliminar permanentemente? [y/N]:${RESET} " ans

    if [ "$ans" = "y" ]; then
        errors=0
        while IFS= read -r -d $'\n' file; do
            [ -z "$file" ] && continue
            printf "%bEliminando %s...%b" "${MAGENTA}" "$file" "${RESET}"
            if rm -rf "$file"; then
                printf "\r%b%-50s %b%s%b\n" "${GREEN}" "${CHECK} $file" "${RESET}" "OK"
            else
                printf "\r%b%-50s %b%s%b\n" "${CYAN}" "${CROSS} $file" "${RESET}" "ERROR"
                ((errors++))
            fi
        done <<< "$fx"

        [ $errors -eq 0 ] && status="${GREEN}Completado sin errores${RESET}" || status="${CYAN}Completado con $errors error(es)${RESET}"
        printf "%b%s%b\n" "${BOLD}" "Resultado: $status" "${RESET}"
        read -p "${BOLD}${MAGENTA}Presione Enter para continuar...${RESET}"
        lf -remote "send load"
    else
        printf "%b%s%b\n" "${BOLD}${MAGENTA}" "${CROSS} Operación cancelada" "${RESET}"
        read -p "${BOLD}${MAGENTA}Presione Enter para continuar...${RESET}"
    fi
}}

cmd checksum ${{
    # Determinar archivos a procesar usando $fx
    files="$fx"

    # Validar que existan archivos
    if [ -z "$files" ]; then
        echo "No hay archivos para procesar"
        read -p "${BOLD}${MAGENTA}Presione Enter para continuar...${RESET}"
        return
    fi

    # Selección de algoritmo
    printf "Seleccione algoritmo:\n1) MD5\n2) SHA256\n3) SHA1\n"
    read -p "Opción: " algo

    case $algo in
        1) checksum="md5sum" ;;
        2) checksum="sha256sum" ;;
        3) checksum="sha1sum" ;;
        *) return ;;
    esac

    # Procesar todos los archivos
    for file in $files; do
        printf "\n${BOLD}${CYAN}%s:${RESET}\n" "$file"
        $checksum "$file" | awk '{print $1}'
    done

    read -p "${BOLD}${MAGENTA}Presione Enter para continuar...${RESET}"
}}

cmd permissions ${{
    clear
    stat -c "Nombre: %n" "$f"
    stat -c "Tamaño: %s bytes" "$f"
    stat -c "Permisos: %A" "$f"
    stat -c "Dueño: %U:%G" "$f"
    stat -c "Último acceso: %x" "$f"
    stat -c "Última modificación: %y" "$f"
    echo "Presione cualquier tecla para continuar..."
    read -n1
}}

# Comando para firmar archivos con GPG
cmd firmar ${{ 
    # Configuración de estilos
    BOLD=$(tput bold)
    BLUE=$(tput setaf 4)
    MAGENTA=$(tput setaf 5)
    CYAN=$(tput setaf 6)
    GREEN=$(tput setaf 2)
    RED=$(tput setaf 1)
    RESET=$(tput sgr0)
    CHECK=$'\u2713'  # ✓
    CROSS=$'\u2717'  # ✗

    clear

    # Verificar si GPG está instalado
    if ! command -v gpg &>/dev/null; then
        printf "%b%s%b\n" "${RED}${BOLD}" "${CROSS} Error: GPG no está instalado" "${RESET}"
        read -p "${BOLD}${MAGENTA}Presione Enter para continuar...${RESET}"
        return 1
    fi

    # Encabezado
    printf "%b%s%b\n" "${BOLD}${BLUE}╭── FIRMAR ARCHIVO ───${RESET}"
    printf "%bArchivo seleccionado:%b\n" "${BOLD}" "${RESET}"
    echo "  $f"
    printf "%b%s%b\n" "${BOLD}${BLUE}╰──────────────────────${RESET}"

    # Mostrar claves disponibles
    printf "%bClaves GPG disponibles:%b\n" "${BOLD}" "${RESET}"
    gpg --list-secret-keys --keyid-format LONG | grep -A1 sec | awk '{ if (NR%3==1) print $2 }' | cut -d'/' -f2 | while read -r key; do
        gpg --list-key "$key" | awk '/uid/ {print "  " $0}'
    done

    # Solicitar ID de clave
    read -p "${BOLD}${MAGENTA}ID de clave GPG (dejar vacío para predeterminada): ${RESET}" key_id

    # Confirmar firma
    read -p "${BOLD}${MAGENTA}¿Firmar el archivo? [y/N]: ${RESET}" ans
    if [ "$ans" = "y" ]; then
        # Construir comando de firma
        if [ -z "$key_id" ]; then
            cmd="gpg --detach-sign --armor \"$f\""
            output_file="$f.asc"
        else
            cmd="gpg --detach-sign --armor -u \"$key_id\" \"$f\""
            output_file="$f.$key_id.asc"
        fi

        # Ejecutar firma
        printf "%b%s%b\n" "${CYAN}⌛ Firmando archivo...${RESET}"
        if eval "$cmd"; then
            printf "\r%b%-50s %b%s%b\n" "${GREEN}" "${CHECK} Éxito: " "${RESET}" "Firma creada: $output_file"
            lf -remote "send load"
        else
            printf "\r%b%-50s %b%s%b\n" "${RED}" "${CROSS} Error: " "${RESET}" "Fallo en la firma"
        fi
    else
        printf "%b%s%b\n" "${MAGENTA}" "${CROSS} Operación cancelada" "${RESET}"
    fi

    read -p "${BOLD}${MAGENTA}Presione Enter para continuar...${RESET}"
}}

# Comando para encriptar archivos con GPG
cmd encriptar ${{
    bash ~/.config/lf/scripts/encrypt.sh "$fx"
}}

# Seleccionar múltiples archivos con FZF
cmd seleccionar_fzf ${{
    res="$(fd --type f --hidden --exclude .git . | fzf --multi --reverse --header='Selecciona archivos (TAB)')"
    if [ -n "$res" ]; then
        # lf -remote "send $id unselect"
        printf '%s\n' "$res" | while IFS= read -r file; do
            lf -remote "send $id select \"$PWD/$file\""
            lf -remote "send $id toggle"
        done
    fi
}}

# Mapeo de Teclas
map <enter> open
map D delete
map E extract
map Z comprimir
map T nuevo

# Mapeos de teclas para operaciones comunes
map <f-7> push :mkdir<space>""<left>
map <c-r> reload
map <c-s> set hidden!
map x $$f
map X !$f

# Mapeos de teclas para renombrar
map A :rename; cmd-end
map C push A<c-u>
map I :rename; cmd-home
map i :rename
map a :rename; cmd-right

# Navegación y operaciones misceláneas
map <c-n> down
map <c-p> up
map V push :!vim<space>
map Y $printf "%s" "$fx" | wl-copy
map gs :fzf_search
map gf :fzf_jump
map S firmar
map M seleccionar_fzf
map <c-e> encriptar

